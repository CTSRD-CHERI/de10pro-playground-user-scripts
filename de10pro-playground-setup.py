#! /usr/bin/env python3

import urllib.request
import subprocess
import datetime
import tempfile
import argparse
import pathlib
import shutil
import jinja2
import yaml
import sys
import os

def gen_vm_image():
  raise NotImplementedError()

def report(params={}, comment_pfx='#'):
  rpt=[]
  rpt.append(f'{comment_pfx} file generated by {pathlib.Path(__file__).name}')
  rpt.append(f'{comment_pfx} (https://github.com/CTSRD-CHERI/de10pro-playground-user-scripts.git)')
  rpt.append(f'{comment_pfx} {datetime.datetime.now()}')
  rpt.append(f'{comment_pfx} template file rendered with parameters:')
  for k, v in params.items(): rpt.append(f'{comment_pfx} {k} = {v}')
  return '\n'.join(rpt)

def require_cmd(cmd):
  if shutil.which(cmd) is None:
    print(f'\n/!\\ "{cmd}" is not available /!\\\n', file=sys.stderr)
    exit(1)

def main_process(tmpl_env, tmpl_params, clargs):

  # always render templates
  #if clargs.subcmd == 'render-templates':
  # run through each templates in the given template parameter configurations
  # and generate the parameterized render
  for t, ps in tmpl_params.items():
    lines = tmpl_env.get_template(t).render(**ps).split('\n')
    if lines[0][0:2] == '#!':
      lines.insert(1, '\n'+report(ps))
    else:
      lines.insert(0, report(ps)+'\n')
    r = '\n'.join(lines)
    with open(f'{clargs.output_path}/{t}', mode='w') as f: f.write(r)

  if clargs.subcmd == 'generate-vm-image':
    print('generate-vm-image')
    cloud_init_user_data=f'{clargs.output_path}/vm-cloud-init/user-data'
    cloud_init_meta_data=f'{clargs.output_path}/vm-cloud-init/meta-data'
    ubuntu_img_url="https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img"
    vm_img, _ = urllib.request.urlretrieve(ubuntu_img_url)
    require_cmd('qemu-img')
    subprocess.run(['qemu-img', 'resize', vm_img, '16G'])
    cloud_init_iso = tempfile.NamedTemporaryFile()
    require_cmd('mkisofs')
    subprocess.run([ 'mkisofs', '--output', cloud_init_iso.name
                   , '-volid', 'cidata', '-joliet', '-rock'
                   , cloud_init_user_data, cloud_init_meta_data ])
    subprocess.run([ 'qemu-system-x86_64', '-enable-kvm', '-m', '2048'
                   , '-machine', 'q35'
                   , '-drive', f'file={vm_img},if=virtio'
                   , '-drive', f'driver=raw,file={cloud_init_iso.name},if=virtio'
                   , '-nographic' ])
    shutil.move(vm_img, f'{clargs.output_path}/{clargs.vm_image_name}')
    os.remove(cloud_init_iso.name)

if __name__ == '__main__':

  # command line arguments
  parser = argparse.ArgumentParser(description='setup de10pro playground files')
  subparsers = parser.add_subparsers(
    dest='subcmd'
  , help='sub-command (run with -h on a specific sub-command for further help)' )

  # general, common options
  parser.add_argument(
    '--template-parameters', metavar='YAML_TEMPLATE_PARAMETERS'
  , help="The YAML_TEMPLATE_PARAMETERS yaml file with the jinja template parameters to use")
  parser.add_argument(
    '-o', '--output-path', metavar='OUT_PATH', default='./output'
  , help='The OUT_PATH path to the output directory' )

  common_parser = argparse.ArgumentParser(add_help=False)
  # render templates clarg parser
  templ_render_parser = subparsers.add_parser(
    'render-templates', parents=[common_parser], help='Render jinja templates' )

  # generate a VM image
  vm_image_parser = subparsers.add_parser(
    'generate-vm-image', parents=[common_parser], help='Generate a vm image' )
  vm_image_parser.add_argument(
    '-n', '--vm-image-name', metavar='VM_NAME', default='de10pro-playground-vm'
  , help='The VM_NAME name to give to the vm image' )

  # parse command line arguments
  clargs=parser.parse_args()

  # prepare templates and parameters
  tmpl_env = jinja2.Environment(loader=jinja2.FileSystemLoader('templates/'))
  tmpl_params = {k: {} for k in tmpl_env.list_templates()}
  if hasattr(clargs, 'template_parameters') \
     and clargs.template_parameters is not None:
    with open(clargs.template_parameters, mode='r') as f:
      tmpl_params = yaml.safe_load(f)

  # ensure output folders exists
  os.makedirs(clargs.output_path, exist_ok=True)
  for p in map(pathlib.Path, tmpl_params.keys()):
    os.makedirs(f'{clargs.output_path}/{p.parent}', exist_ok=True)

  # there must be a sub-command
  if not hasattr(clargs, 'subcmd') or clargs.subcmd is None:
    print('\n/!\\ No sub-command was passed /!\\\n', file=sys.stderr)
    parser.print_help(sys.stderr)
    sys.exit(1)

  main_process(tmpl_env, tmpl_params, clargs)
